## Механизм инвалидации кеша

Используется **TTL** для инвалидации кеша в Redis. Кешируются заказы, хранящиеся в виде хеш-ключей и упорядоченных множеств для фильтрации по статусу и по пользователю.

### Хранимые данные

Есть два типа данных:
* Хеш-ключи вида `order:*` содержат информацию о заказах.
* Упорядоченные множества: `orders:by_status:*` и `user:*:orders`. 

В свою очередь множества упорядочены по времени создания заказа, а также содержат в ключе соответвующий статус заказа и пользователя, которому этот заказ принадлежит.

### Пример:

```sh
> keys *
1) "order:2"
2) "orders:by_status:STATUS_ACCEPTED"
3) "user:1:orders"
4) "order:1"
5) "orders:by_status:STATUS_DELIVERED"
> zrange orders:by_status:STATUS_DELIVERED 0 -1
1) "order:1"
> zrange orders:by_status:STATUS_ACCEPTED 0 -1
1) "order:2"
```

### Инвалидация ключей

Каждый хеш-ключ содержит поля: `stored_until` и `return_by`. 

Например:

```sh
> HMGET order:1 stored_until return_by
1) "5138-11-16T09:46:40Z"
2) "2024-07-22T14:11:23.538527375Z"
```

Для ключа `order:2` поле `return_by` еще не установлено:

```sh
> HMGET order:2 stored_until return_by
1) "5138-11-16T09:46:40Z"
2) "0001-01-01T00:00:00Z"
```

Сама инвалидация устанавливается следующим образом:
1. Либо у хеш-ключа устанавливается TTL, равный значению `stored_until`.
2. Либо если поле `return_by` в запросе задается - то оно.

### Удаление элементов из множеств при истечении TTL

При истечении срока действия хеш-ключа, соответствующий элемент должен быть удален из всех связанных множеств.

Происходит это следующим образом. При запросе какого-то заказа, если ничего не возвращается, то соответствующие поля удаляются.

### Причина использования

Самый очевидный способ, что сразу приходит в голову, потому что нету никакого смысла хранить в кеше просроченные заказы.